---
title: "[네트워크 보안] 대칭 암호화"
description: "대칭 암호화 방식에 대해서"
date: 2024-09-09T08:49:00.465Z
tags: ["네트워크 보안"]
slug: "네트워크-보안-대칭-암호화"
thumbnail: "https://velog.velcdn.com/images/jaewon-ju/post/83e19bff-c470-4ccc-b551-a91c940ba28e/image.png"
categories: Network
toc: true
velogSync:
  lastSyncedAt: 2025-08-19T11:39:00.683Z
  hash: "604957423888415ad36aaf3ecd6feb8986a13dfa9d8e5e9a6a04b11a6bf02db3"
---

## ✏️ 대칭키 암호화 및 암호 해독 기법
### ■ 대칭키 암호화란?
>대칭키 암호화는 암호화와 복호화에 동일한 키를 사용하는 암호화 방식이다. 

이 방식에서는 동일한 키로 데이터를 암호화하고, 다시 그 동일한 키로 복호화할 수 있다. 중요한 점은 이 비밀키를 안전하게 공유하는 것이며, 이를 소홀히 할 경우 보안에 치명적인 위험이 발생할 수 있다.

대칭키 암호화의 주요 특징:
- 암호화와 복호화에 동일한 키를 사용한다.
- 암호화 알고리즘을 공개해도 비밀키가 없으면 데이터를 해독할 수 없다.
- 일반적으로 암호화 알고리즘을 **역방향(reverse)** 으로 수행하면 복호화가 가능하다.


<br>


### ■ 대칭키 암호화의 분류
1. Block Cipher (블록 암호)

- 한 번에 한 블록씩 고정된 크기의 데이터를 입력으로 받아 암호화한 후, <span style = "color:red">동일한 크기의 블록</span>을 출력하는 방식이다.

- DES, 3DES, AES

| 설계 요소 | 성능|
| - | - |
| 블록 크기| 클수록 강력 |
| 키 크기 | 클수록 강력 |
| 라운드 수 | 클수록 강력|
| 서브키 생성 알고리즘 | 복잡할수록 강력|
| 라운드 함수| 복잡할수록 강력|
| 알고리즘의 구조 | 간결해야함 |


<br>

2. Stream Cipher (스트림 암호)

**데이터를 연속적인 흐름(stream)** 으로 처리하며, 한 번에 한 비트 또는 한 바이트씩 암호화한다.
실시간 데이터 처리에 적합하며, 주로 통신에서 많이 사용된다.

<br>

### ■ 암호 해독(cryptanalysis)의 유형
암호 해독은 암호화된 데이터를 키 없이 해독하려는 시도를 의미하며, 다양한 공격 기법이 존재한다.

1. Brute-force Attack (무차별 대입 공격)
: 가능한 모든 키를 하나씩 대입해 암호문을 해독하려는 방식이다.

2. Known Plaintext Attack (알려진 평문 공격)
: 공격자는 일부 평문과 그에 대응하는 암호문을 알고 있다. 
이를 바탕으로 암호문을 해독하려고 시도한다.

3. Chosen Plaintext Attack (선택된 평문 공격)
공격자는 자신이 선택한 평문을 암호화하여 그 결과인 암호문을 얻는다. 
이를 바탕으로 암호문을 해독하려고 시도한다.

4. Chosen Ciphertext Attack (선택된 암호문 공격)
공격자는 자신이 선택한 암호문을 복호화한 평문을 얻어내는 방식이다. 이를 통해 복호화 과정의 약점을 이용하여 전체 키를 추정할 수 있다.

5. Chosen Text Attack (선택된 텍스트 공격)
공격자는 평문과 암호문을 모두 선택할 수 있으며, 이 데이터를 통해 암호화 시스템의 약점을 분석한다.

모두 암호 알고리즘과 해독해야 할 암호문은 이미 가지고 있다.

<br>

---

<br>

## ✏️ Block Cipher

### ■ Feistel 암호화
> Encryption과 Decryption 방식이 동일한 암호화 구조.

<span style = "color:red">⚠️</span> Feistel 구조(Feistel network)는 블록 암호(block cipher) 설계에 자주 사용되는 구조일 뿐, 자체적으로 블록 암호는 아니다.

암호화: K1부터 시작
복호화: K16부터 시작

특징을 알고 있어야 함.

<br>

### ■ DES (Data Encryption Standard)
DES는 1977년에 표준으로 채택된 대칭 키 암호화 알고리즘으로, **Feistel 구조**를 변형한 방식이다.

- **평문 크기**: 64비트
- **키 크기**: 56비트
- **서브키 크기**: 48비트
- **라운드 수**: 16라운드
- **서브키 수**: 16개 (암호화 과정에서 사용되는 서브키)

DES는 원래 64비트의 키를 사용하지만, 실제로는 **56비트**만이 유효하며, 나머지 8비트는 패리티 비트로 사용된다. **16개의 48비트 서브키**는 원래 키에서 생성되며, 암호화 과정에서는 순차적으로, 복호화 과정에서는 **역순**으로 적용된다.

#### ❗ DES의 한계
- **키 길이의 부족**: 56비트 키는 현대적인 공격에 취약하다.
- **보안 취약점**: DES는 이미 **브루트 포스** 공격에 의해 깨졌다.

<br>

### ■ 3DES (Triple DES)
3DES는 DES의 단점을 보완하기 위해 **DES 알고리즘을 세 번 적용**하는 방식으로 설계되었다. 세 개의 서로 다른 키를 사용해 암호화와 복호화를 진행한다.

- **키 크기**: 168비트 (56비트 x 3)
- **암호화**: ```Cipher = E(K3, D(K2, E(K1, Plain)))```
- **복호화**: ```Plain = D(K1, E(K2, D(K3, Cipher)))```
- **블록 크기**: 64비트
- **속도**: DES를 3번 적용하므로 속도가 느리다.

3DES는 DES보다 훨씬 더 강력한 보안을 제공하지만, 여전히 **속도 문제**와 **블록 크기(64비트)**로 인한 제약이 있다.

<br>

### ■ AES (Advanced Encryption Standard)
>AES는 DES와 3DES의 한계를 극복하기 위해 2001년에 제정된 **대칭 키 블록 암호화 표준**이다. 
AES는 DES와 달리 <span style = "color:red">Feistel 구조가 아니며</span>, 암호화와 복호화가 서로 다른 알고리즘을 사용한다.

- **블록 크기**: 128비트
- **키 길이**: 128, 192, 256비트
- **라운드 수**: 키 길이에 따라 10, 12, 14라운드
- **라운드 키 크기**: 128비트

<br>

#### AES 암호화
1. **바이트 대체 (SubBytes)**: **S-Box**를 이용해 각 바이트를 대체.
2. **행 이동 (ShiftRows)**: 블록 내의 행을 **좌측으로 순환 이동**.
3. **열 섞기 (MixColumns)**: 열 단위로 **선형 변환**을 적용하여 데이터를 섞음.
4. **라운드 키 더하기 (AddRoundKey)**: 현재 블록에 **라운드 키**를 XOR 연산으로 더함.

<br>

#### AES 복호화
복호화 과정은 암호화 과정과 반대 순서로 진행된다. 각 단계는 암호화에서 사용된 연산의 **역연산**을 수행한다.

1. **ShiftRows**의 역연산
2. **SubBytes**의 역연산 (S-Box의 역함수)
3. **AddRoundKey** (동일한 XOR 연산)
4. **MixColumns**의 역연산

AES는 3DES에 비해 **보안성이 높고** 연산 속도가 빠르기 때문에, 현재 널리 사용되고 있는 표준 암호화 알고리즘이다.

순서 외우지 마셈


<br>

---

<br>

## ✏️ Random Number
랜덤 넘버는 다음과 같은 경우에 사용된다:

- **대칭 스트림 암호**에서 스트림 키 생성
- **대칭키** 생성 (임시 세션키)
- **비대칭 암호화(RSA)** 알고리즘에서 키 생성
- **Kerberos**에서 키 배포 시 사용

<br>

### ■ 랜덤 넘버의 특징
1. **무작위성 (Randomness)**
   - **균등 분포**: 랜덤 수열의 비트 분포는 균등해야 한다.
   - **독립성**: 수열의 일부로부터 다른 수열을 추론할 수 없어야 한다. 독립성의 증명은 불가능하다.

2. **예측 불가능성 (Unpredictability)**
   - **수열의 일부**로부터 다음 수를 예측할 수 없어야 한다.
   - **진성 랜덤넘버**: 수열의 모든 수가 독립적이므로 예측이 불가능하다.

>#### 독립성 vs 예측불가능성
- **독립성**: 수열 [1,2,3,4,5,6]에서 4번째 값이 무엇인지 다른 수열로부터 예측할 수 없다.
- **예측불가능성**: 수열 [1,2,3,4,5,6]에서 3번째 값으로부터 4번째 값을 예측할 수 없다.

따라서, **독립성**이 존재하면 **예측불가능성**은 자연스럽게 따라온다.

- **Pseudorandom Number**: 무작위성이 없지만, 다양한 무작위성 테스트를 통과하는 알고리즘.

<br>

### ■ TRNG, PRNG, PRF
- **TRNG (True Random Number Generator)**
: 실제 랜덤 값을 input으로 사용하여 **진성 랜덤넘버**를 생성.

- **PRNG (Pseudorandom Number Generator)**
: seed를 input으로 사용하며, **고정 길이의 의사 랜덤 비트열**을 생성한다. 
대칭키 암호화에서 주로 사용된다.
- **PRF (Pseudorandom Function)**
: seed 값을 input으로 사용하여 **의사 랜덤넘버**를 생성. 
**Nonce**나 **대칭 암호키** 생성에 사용된다.

![](https://velog.velcdn.com/images/jaewon-ju/post/7b41b231-5855-4223-ace3-71b2daa7e271/image.png)
PRNG와 PRF는 모두 <span style = "color:red">**deterministic**</span>하다.

<br>

### ■ PRNG 알고리즘 설계
1. **특정 목적의 알고리즘**: RC4 등 특정한 암호화 방식에 맞추어 설계된 알고리즘.
2. **기존 암호 알고리즘**을 이용한 알고리즘: 암호문이 특정 패턴을 가지지 않도록 설계된다.

PRNG에 사용되는 대표적인 암호 알고리즘:
- **대칭 블록 암호 알고리즘**
- **비대칭 암호 알고리즘**
- **해시 함수** 및 **메시지 인증 코드(MAC)**

<br>

## ✏️ Stream Cipher
>스트림 암호화는 평문과 키 스트림을 XOR 연산하여 암호문을 생성하는 방식이다.

- **암호화**: ```Cipher = Text XOR Key Stream```
- **복호화**: ```Text = Cipher XOR Key Stream```

#### 주의 사항
- **키 스트림**은 매우 긴 **의사 랜덤 넘버 수열**이어야 하며, 주기가 없어야 한다.
- **진성 랜덤 넘버**에 가까운 키 스트림을 만들어야 한다.
- **128비트 이상의 키 길이**가 필요하다.

<br>

### ■ 스트림 암호 vs 블록 암호
**스트림 암호**:
- 처리 속도가 빠르다.
- 코드 양이 적다.
- **데이터 통신 채널**이나 **웹 브라우저** 데이터 스트림 암호화에 적합하다.

**블록 암호**:
- **키 재사용**이 가능하다.
- **파일 전송**이나 **데이터베이스**와 같은 데이터 블록 암호화에 적합하다.

<br>

### ■ RC4
- **스트림 암호 방식**으로, **바이트 단위**로 작동한다.
- **SSL/TLS**, **WEP**, **WPA**에서 사용되었다.

1. S, T Initialization
```c
for i = 0 to 255 do
	S[i] = i;
    T[i] = K[i mod (K의 바이트 수)];
    // T는 256 bytes고, K는 256보다 작을 수 있다.
    // Key Length만큼 K가 반복적으로 들어간다
```
![](https://velog.velcdn.com/images/jaewon-ju/post/dccea976-9c13-4c4b-86d4-f9260ff07363/image.png)

2. S의 Permutation
```c
j = 0
for i = 0 to 255 do
	j = (j + S[i] + T[i]) mod 256;
    SWAP(S[i], S[j]);
```

3. Stream Generation
```c
i,j = 0
while(true)
	i = (i + 1) mod 256;
    j = (j + S[i]) mod 256;
    SWAP(S[i], S[j]);
    t = (S[i] + S[j]) mod 256;
    k = S[t];
    // k
```

Deterministic하다.
결국에는 송신과 수신이 동일한 키를 가지게 된다.

<br>

---

<br>

## ✏️ Cipher Block Modes Of Operation

블록 사이퍼 운용 모드

if, Pi = Pj => Ci should not = Cj

1. ECB(Electronic Codebook Mode)
2. CBC(Cipher Block Chaining Mode)
3. CFB(Cipher Feedback Mode)
4. CTR(Counter Mode)

<br>

### 1. ECB
![](https://velog.velcdn.com/images/jaewon-ju/post/f0e0a85a-8f3d-492c-943e-428781e0644b/image.png)

- 평문을 b 비트 크기의 블록으로 분해
- 각 블록을 <span style = "color:red">동일한 키</span>로 암호화
- 하나의 평문 블록에 하나의 암호 블록이 대응
- 평문의 패턴이 <span style = "color:red">그대로 드러난다</span>.


<br>

### 2. CBC
![](https://velog.velcdn.com/images/jaewon-ju/post/8457c06e-7529-4c1e-9ec2-e60ac473d90e/image.png)

```C = E(C_(i-1) ⊕ P_i)```
IV: Initial Vector

- 각 블록을 <span style = "color:red">동일한 키</span>로 암호화
- IV를 첫번째 평문블록과 XOR
   - 송수신자는 동일한 IV를 갖고 있다.
   - IV는 <span style = "color:red">절대 노출되면 안된다.</span> 
- 평문 블록 열 처리를 한 줄로 연결한 것


<br>

복호화
```
D(C) = D(E(C_(i-1) ⊕ P_i))
	 = C_(i-1) ⊕ P_i
     
C_(i-1) ⊕ D(C) = C_(i-1) ⊕ C_(i-1) ⊕ P_i
			   = P_i
```

따라서, ```C_(i-1) ⊕ D[C_(i)] = P_(i)```

<br>

>#### IV 보호
공격자가 IV의 특정 비트 값을 바꿀 수 있다면, 해당 bit position이 뒤집힌 값이 나온다.



> #### CBC의 문제점
속도 문제
오류 확산

<br>


### 3. CFB
![](https://velog.velcdn.com/images/jaewon-ju/post/c90df7e4-684d-4018-bd74-4317732a633b/image.png)


```P = C ⊕ S_s(E(IV))```

S_s: shift register S의 left most s bits

- 동일 키 사용
- CBC와 다르게, Encryption을 IV에다가 함
- 블록보다는 Stream 처럼 보임

어떤 블록 암호도 스트림 암호로 변경할 수 있다.

- 스트림 암호의 장점: 메시지를 블록 정수배로 안만들어도 됨, 실시간 사용 가능, 암호문 길이 = 평문 길이

- 암호 알고리즘 입력: 64bit shift register S(초기값 = IV), 키(K)

복호화
```P = C ⊕ S_s(E(IV))```

<br>

### 4. CTR
![](https://velog.velcdn.com/images/jaewon-ju/post/b4faa67a-b495-4e9b-aa67-ea07705e0bfc/image.png)

카운터
- 평문 블록과 같은 크기
- 평문 블록 별로 상이한 카운터 값(대체로 이전꺼에 + 1)

암호화
- 키를 사용해서 <span style = "color:red">카운터를 암호화</span> (카운터를 미리 암호화할 수 있기 때문에 빠름)
- 암호화된 카운터와 평문 블록을 XOR
- <span style = "color:red">체인을 사용하지 않는다!</span>

복호화
- 암호화와 동일한 카운터 값을 사용한다.


>#### CTR의 장점
- 병렬처리 가능
- 랜덤 접근(블록 한개만도 복호화 가능)
- 보안성이 좋음
- 단순성


!!
ATM 네트워크
IPSec에서 사용
!!






---
title: "[CS 지식] 주소 연산"
description: "0x00과 0x01 간의 차이는 왜 1 byte인가?"
date: 2024-01-14T14:06:09.525Z
tags: ["CS지식"]
slug: "CS-지식-주소-연산"
toc: true
velogSync:
  lastSyncedAt: 2025-08-19T11:39:03.496Z
  hash: "704234a4c0f45cab5fefab81ab3edc8de0fee85566fefe70c6c22468e4558be7"
---

Java를 공부하다가, 메모리와 관련된 부분이 나왔다. Java의 메모리 구조에 대해서 공부하는김에 C 언어 메모리 구조도 한번 복습해야겠다~~ 해서 쭉 정리를 해봤다.

근데 정말 뜬금없이 이해 안되는 부분이 생겼다. 머릿속으로 정리를 다 끝낸 지금 다시 생각해보면, 이게 왜 헷갈렸지...? 싶을 정도의 의문점이긴 한데,, 나중에 또 갑자기 이런일이 생길 수도 있으니까 정리해두려 한다.

## ✏️ 의문점
C 언어에서 주소는 16진수로 표현한다. 16진수 하나는 4bit를 나타내므로, 32 bit 체제의 컴퓨터에서는 0x00000000 이런식으로 표현된다.
> #### 의문점: 0x00000000와 0x00000004 간의 차이가 왜 4 byte지?

나의 의문점은 16진수 각 자리수가 4 bit를 나타낸다는 것에서 비롯되었다.
예를 들어, 다음과 같은 배열이 있다고 해보자.
```c
int scores[5] = {1,2,3,4,5};
```
scores[0]의 주소가 0x00000000이라고 가정해보자.
scores[1]의 주소는 0x00000000에서 int 형 변수의 크기인 4 bytes 만큼을 더한 값이 될 것이다.

내 머릿속의 로직은 이러했다.

> 0x00000000에 4 bytes(32 bits)를 더하자 
--> 16진수 하나는 4 bit 
--> 0x00000000은 2 진수로 0000 0000 0000 .... 0000 
--> 2진수 0000 0000 0000 .... 0000 에 1 bit 씩 32번 더하면 결과가 나오겠네! 
--> .... 0010 0000
--> 0x00000020
근데 원래는 0x00000004가 맞는데...?

지금 보면 정말 이상한 흐름이지만, 그 때는 뭐가 이상한지를 몰랐다.

## ✏️ 해결
<span style = "color: red">주소는 바이트 단위로 표현한다!!!</span>
16 진수는 그냥 표현의 방식일 뿐이다. 16 진수 하나가 4 bit를 나타내는 것은 주소의 연산과 무관하다. 
100cm + 1cm을 계산할 때, 1cm가 10mm인 것을 고려하지 않듯이..



## REFERENCE
나랑 비슷한 의문점이 생긴 사람이 있었나보다...
https://stackoverflow.com/questions/75122597/understanding-hexadecimal-and-memory-addresses